# 1、字典编码流程

## 1.1、图片编码

### 1.1.1、图片padding

输入的图片为img，其高为H，宽为W。由于进行提升小波变换需要图片的行和列都是8的倍数，所以对于不是8的倍数的H和W，需要人为将边缘补齐，这里提供了4种补齐操作。分别是①extend：将原始图片的最后一行与最后一列的数据向外延申补齐②periodic：将原始图片的初始的行和列粘贴到图片最后的行和列③mirror：与原始图片最后数据成对称补齐④zeros：补0.

举例如下
$$
img= \\ 
[1,2,3,4,5,6\\1,2,3,4,5,6\\1,2,3,4,5,6\\1,2,3,4,5,6\\1,2,3,4,5,6\\1,2,3,4,5,6]\\
extend=\\ 
[1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6\\1,2,3,4,5,6,6,6]\\
periodic= \\ 
[1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2\\1,2,3,4,5,6,1,2]\\
mirror=\\ 
[1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5\\1,2,3,4,5,6,6,5]\\
zeros=\\ 
[1,2,3,4,5,6,0,0\\1,2,3,4,5,6,0,0\\1,2,3,4,5,6,0,0\\1,2,3,4,5,6,0,0\\1,2,3,4,5,6,0,0\\1,2,3,4,5,6,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0]
$$

### 1.1.2、提升小波变换

主要由三个步骤组成：①分裂②预测③更新

①分裂：将原始信号分裂为两个集合，这里采用最常用的惰性分裂，即对原始信号X(n)进行奇偶采样，偶采样得到的构成集合Xe(n)，奇采样构成集合Xo(n).

② 预测：由于Xe(n) 和Xo(n) 都是通过对信号 X(n) 进行采样得到的，所以Xe(n) 和Xo(n) 之间必定存在着高度的相关性。因此，可以利用其中一个集合来预测另一个集合。通常习惯就是利用偶子集 Xe(n) 来预测奇子集Xo(n) ，其 预测误差定义为：
$$
d(n) = X_o(n)-P(X_e(n))
$$
等式中的 P(Xe(n))为预测算子。通常采用多项式插值作为预测算子，当确定预测算子之后，便可以通过偶子集 Xe(n) 和预测误差 d(n) 来恢复奇子集Xo(n) ，进而可以恢复原始信号 X(n) 
$$
X(n) = X_e(n)+X_o(n) = X_e(n)+d(n)+P(X_e(n))
$$
 由于预测误差 d(n) 表示原始信号 X(n) 局部区域的低频分量误差，故预测误差 d(n) 可看作是信号的高频分量。 

③更新： 低频信号保留了原始信号的绝大部信息，为了使其更逼近原始信号的整体特征（如均值等），确保整体特性和原始信号相同，则需要一个更新过程，来对数据进行修正，U为更新算子其过程如下： 
$$
c(n) = X_e(n)+U(d(n))
$$

### 1.1.3、块向量转为列向量

将提升小波变换后的信号分块并转为列向量。

假设padding后的图片为$H\times W$,分成的小块的大小为$Mn\times Nn$,则转换成的列向量大小为$( (Mn\times Nn)\times \frac{H\times W} {Mn\times Nn})$

将$(\frac{H\times W}{Mn\times Nn})$记作L，将$(Mn\times Nn)$记作N，即经过提升小波变换得到的向量X大小为$N\times L$,向量X第一行数据记为Xdc，X除第一行之外数据置0，与Xdc拼接得到直流分量Xr，将向量X第一行置0,其余保持不变作为交流分量，记作Xac.
$$
X= \\ 
[1,2,3,4,5,6,7,8\\2,2,3,4,5,6,7,8\\3,2,3,4,5,6,7,8\\4,2,3,4,5,6,7,8\\5,2,3,4,5,6,7,8\\6,2,3,4,5,6,7,8\\7,2,3,4,5,6,7,8\\8,2,3,4,5,6,7,8]\\
Xdc= \\ 
[1,2,3,4,5,6,7,8]\\
Xr= \\ 
[1,2,3,4,5,6,7,8\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0\\0,0,0,0,0,0,0,0]\\
Xac= \\ 
[0,0,0,0,0,0,0,0\\2,2,3,4,5,6,7,8\\3,2,3,4,5,6,7,8\\4,2,3,4,5,6,7,8\\5,2,3,4,5,6,7,8\\6,2,3,4,5,6,7,8\\7,2,3,4,5,6,7,8\\8,2,3,4,5,6,7,8]\\
$$


### 1.1.4、 稀疏表示

因为交流变量Xac值均比较小，且0值较多，可以使用稀疏编码，这里调用java库 

​    Methods implemented in the 'mpv2' java package (by K. Skretting)
​    see page: http://www.ux.uis.no/~karlsk/dle/index.html
​    They are all variants of Matching Pursuit
​    'javaMP', 'javaMatchingPursuit', 'javaBMP', 'javaBasicMatchingPursuit'
​    'javaOMP' or 'javaOrthogonalMatchingPursuit'
​    'javaORMP' or 'javaOrderRecursiveMatchingPursuit'
​    'javaPS' or 'javaPartialSearch'

只在编码段使用

### 1.1.5、 量化

将直流分量和稀疏矩阵的权重量化为Zdc和Zw

量化前的变量记为X， 量化后的变量记为Y， threshold记为thr，量化间隔记为delta
$$
S = sign(X)\\
Y = \frac{abs(X)-thr}{dele}+1\\
Y = Y*S
$$


### 1.1.6、 对稀疏编码权重处理便于后续熵编码

具体过程如下：

假设对权重W进行reshape，将W转换为4个list

其中第一个list存储权重W的大小信息（行列数）

第二个list存储权重中的非0值

第三个list存储权重的索引的DPCM中小于largelimit的值

第四个list存储权重中的大值

### 1.1.7、 对直流信息处理便于后续编码

若输入直流向量信息较小（行列均小于6或者总数小于100），使用DPCM储存

若输入直流向量信息较多，使用类似CALIC的方式储存。上方记为N，下方记为S，左方记为W，右方记为E

当前像素记为CP

| WWNN | NNW  |  NN  |
| :--: | :--: | :--: |
| WNW  |  NW  |  N   |
|  WW  |  W   |  CP  |
| WWS  |  WS  |      |
| WWSS |      |      |

### 1.1.8、 熵编码

直接使用zlib库（可以尝试zstd,lz4等库）

## 1.2 图像解码

### 1.2.1、熵解码

 直接使用对应熵编码库进行熵解码

### 1.2.2、 bytes2list

eval函数，将bytes数据转为数字存储在list中

### 1.2.3、 稀疏矩阵权重进行1.1.6中逆操作

### 1.2.4、直流信息进行1.1.7中逆操作

### 1.2.5、量化并恢复

